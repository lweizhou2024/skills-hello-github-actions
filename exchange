from odbAccess import openOdb
import numpy as np
import math, sys, csv

# ---------------------------------------------------------------------
# USER INPUT
odb_path = 'yourfile.odb'        # path to your ODB
tgonode_file = 'tgonodes.txt'    # file with comma/space separated node labels
output_csv = 'band_stress.csv'   # output file
element_set_name = 'TGOELEM'     # element set of the band
stress_component = 'S11'         # choose the component (S11, S22, etc.)
step_name = 'Step-1'             # step name to read from
frame_number = -1                # last frame
# ---------------------------------------------------------------------

print('Opening ODB: %s' % odb_path)
odb = openOdb(path=odb_path)
root_assembly = odb.rootAssembly
step = odb.steps[step_name]
frame = step.frames[frame_number]

# --- read node labels from file ---
node_labels = set()
with open(tgonode_file, 'r') as f:
    for line in f:
        for tok in line.replace(',', ' ').split():
            try:
                node_labels.add(int(tok))
            except:
                pass
print('Read %d node labels from %s' % (len(node_labels), tgonode_file))

# --- get coordinates for these nodes from ODB ---
nodes_coords = {}
for instName, inst in root_assembly.instances.items():
    for n in inst.nodes:
        if n.label in node_labels:
            nodes_coords[n.label] = np.array(n.coordinates[:2])

if len(nodes_coords) == 0:
    print('Could not match any nodes from file in the ODB.')
    odb.close()
    sys.exit(1)
print('Collected %d nodes from ODB.' % len(nodes_coords))

# --- extract stress field for element set ---
if element_set_name in root_assembly.elementSets:
    elemSet = root_assembly.elementSets[element_set_name]
else:
    for instName, inst in root_assembly.instances.items():
        if element_set_name in inst.elementSets:
            elemSet = inst.elementSets[element_set_name]
            break
    else:
        print('Element set "%s" not found.' % element_set_name)
        odb.close()
        sys.exit(1)

stress_field = frame.fieldOutputs['S']
stress_subfield = stress_field.getSubset(region=elemSet, position=ELEMENT_NODAL)

# --- collect stresses at node labels ---
node_stress = {}
for v in stress_subfield.values:
    if v.nodeLabel in node_labels:
        node_stress.setdefault(v.nodeLabel, []).append(v.data)

# average duplicates if needed
for lbl in node_stress:
    node_stress[lbl] = np.mean(node_stress[lbl], axis=0)

if len(node_stress) == 0:
    print('No matching node stresses found in the element set.')
    odb.close()
    sys.exit(1)

# --- build coordinate and stress arrays ---
coords = []
stresses = []
for lbl in node_stress:
    coords.append(nodes_coords[lbl])
    sdata = node_stress[lbl]
    # pick S11, S22, S33, etc.
    comp_map = {'S11':0, 'S22':1, 'S33':2, 'S12':3, 'S13':4, 'S23':5}
    scomp = sdata[comp_map[stress_component]]
    stresses.append(scomp)

coords = np.array(coords)
stresses = np.array(stresses)

# --- find centerline of band ---
# Here we approximate centerline by smoothing coordinates
# sort by x, then use running average to get approximate line
order = np.argsort(coords[:,0])
coords_sorted = coords[order]
stresses_sorted = stresses[order]

# optionally smooth coordinates (if noisy)
window = 5
smooth_x, smooth_y = [], []
for i in range(len(coords_sorted)):
    i1 = max(0, i - window)
    i2 = min(len(coords_sorted), i + window)
    smooth_x.append(np.mean(coords_sorted[i1:i2,0]))
    smooth_y.append(np.mean(coords_sorted[i1:i2,1]))

centerline = np.column_stack((smooth_x, smooth_y))
stresses_center = stresses_sorted

# --- compute arc length ---
arc = np.zeros(len(centerline))
for i in range(1, len(centerline)):
    dx = centerline[i,0] - centerline[i-1,0]
    dy = centerline[i,1] - centerline[i-1,1]
    arc[i] = arc[i-1] + math.sqrt(dx*dx + dy*dy)

# --- save to CSV ---
with open(output_csv, 'w') as f:
    writer = csv.writer(f)
    writer.writerow(['ArcLength', stress_component])
    for s, val in zip(arc, stresses_center):
        writer.writerow([s, val])

print('Wrote stress along band to %s' % output_csv)
odb.close()
