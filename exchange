Step 1. Define your model function
function strain_model = myModel(C, t, s)
    % C: [C1, C2, C3]
    % t: time series (vector)
    % s: scalar condition
    strain_model = (t .* C(1) .* s.^C(2)).^(1./(1 - C(3))) * 100;
end

Step 2. Build the objective function

We want to fit across all experiments.

function err = objectiveFunction(C, data_all, s_all)
    % data_all: cell array of n_i x 2 matrices [time, strain]
    % s_all: vector of conditions, one per dataset

    err = [];
    N = numel(data_all);

    for i = 1:N
        t = data_all{i}(:,1);
        strain_exp = data_all{i}(:,2);
        s = s_all(i);

        strain_model = myModel(C, t, s);

        % residuals (for lsqnonlin)
        err = [err; (strain_model - strain_exp)];
    end
end

Step 3. Run calibration with lsqnonlin
% Example: load your data (cell array, each element is n_i x 2)
% data_all{1} = [time1, strain1];
% data_all{2} = [time2, strain2];
% ...
% s_all = [s1, s2, ...];   % known conditions

% Initial guess for C
C0 = [0.01, 1, 0.5];  % you should pick reasonable starting values

% Lower/upper bounds (optional, to keep parameters physical)
lb = [0, -Inf, -Inf];
ub = [Inf, Inf, 0.99];  % avoid division by 0 if C3 -> 1

% Objective handle
fun = @(C) objectiveFunction(C, data_all, s_all);

% Optimization
options = optimoptions('lsqnonlin','Display','iter','MaxFunctionEvaluations',1e5);
C_best = lsqnonlin(fun, C0, lb, ub, options);

Step 4. Validate results
for i = 1:numel(data_all)
    t = data_all{i}(:,1);
    strain_exp = data_all{i}(:,2);
    s = s_all(i);

    strain_fit = myModel(C_best, t, s);

    figure; 
    plot(t, strain_exp, 'ko', 'DisplayName','Experiment'); hold on;
    plot(t, strain_fit, 'r-', 'LineWidth', 2, 'DisplayName','Model');
    xlabel('Time'); ylabel('Strain');
    legend; title(['Test ' num2str(i)]);
end
