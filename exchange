function [center, direction, radius] = fitCylinder(points)
    % points: Nx3 matrix of (x, y, z)
    
    % 1. Initial Guess
    % Use PCA to find the primary orientation (the cylinder axis)
    avg = mean(points);
    [coeff, ~] = pca(points);
    v0 = coeff(:, 1); % First principal component is a good start for the axis
    p0 = avg;         % Centroid as a point on the axis
    r0 = mean(sqrt(sum((points - avg).^2, 2))) / 2; % Rough guess for radius
    
    % Initial parameter vector: [px, py, pz, vx, vy, vz, r]
    initial_params = [p0, v0', r0];
    
    % 2. Optimization
    options = optimoptions('lsqnonlin', 'Display', 'off', 'FunctionTolerance', 1e-6);
    
    % Define the objective function (residuals)
    objFunc = @(params) cylinderResiduals(params, points);
    
    % Run optimization
    best_params = lsqnonlin(objFunc, initial_params, [], [], options);
    
    % 3. Extract results
    center = best_params(1:3);
    direction = best_params(4:6) / norm(best_params(4:6)); % Normalize
    radius = abs(best_params(7));
end

function res = cylinderResiduals(params, points)
    p = params(1:3);      % Point on axis
    v = params(4:6);      % Axis direction
    v = v / norm(v);      % Ensure unit vector
    r = params(7);        % Radius
    
    % Distance from each point to the axis
    % Formula: ||(q - p) x v||
    diff = points - p;
    distToAxis = sqrt(sum(cross(diff, repmat(v, size(points, 1), 1)).^2, 2));
    
    % Residual is (distance to axis - radius)
    res = distToAxis - r;
end
